/* hyperspi.cpp
*
*  MIT License
*
*  Copyright (c) 2024 awawa-dev
*
*  https://github.com/awawa-dev/HyperSPI
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the "Software"), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in all
*  copies or substantial portions of the Software.

*  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
*  SOFTWARE.
 */

#define TUD_OPT_HIGH_SPEED


#include "FreeRTOS.h"
#include "task.h"
#include <stdio.h>
#include <algorithm>
#include "pico/stdio/driver.h"
#include "pico/stdlib.h"
#include "pico/stdio.h"
#include "pico/stdio_usb.h"
#include "pico/multicore.h"
#include "pico/sem.h"
#include "leds.h"

#define SPI_FRAME_SIZE	1536
#define SPI_SPEED		20833333

uint8_t spiBuffer[SPI_FRAME_SIZE] {};

///////////////////////////////////////////////////////////////////////////
// DO NOT EDIT THIS FILE. ADJUST THE CONFIGURATION IN THE CmakeList.txt  //
///////////////////////////////////////////////////////////////////////////

#define _STR(x) #x
#define _XSTR(x) _STR(x)
#define VAR_NAME_VALUE(var) #var " = " _XSTR(var)
#define _XSTR2(x,y) _STR(x) _STR(y)
#define VAR_NAME_VALUE2(var) #var " = " _XSTR2(var)

#if defined(BOOT_WORKAROUND) && defined(PICO_XOSC_STARTUP_DELAY_MULTIPLIER)
	#pragma message("Enabling boot workaround")
	#pragma message(VAR_NAME_VALUE(PICO_XOSC_STARTUP_DELAY_MULTIPLIER))
#endif


#ifdef NEOPIXEL_RGBW
	#pragma message(VAR_NAME_VALUE(NEOPIXEL_RGBW))
#endif
#ifdef NEOPIXEL_RGB
	#pragma message(VAR_NAME_VALUE(NEOPIXEL_RGB))
#endif
#ifdef COLD_WHITE
	#pragma message(VAR_NAME_VALUE(COLD_WHITE))
#endif

#ifdef NEOPIXEL_RGBW
	#define LED_DRIVER sk6812
#elif NEOPIXEL_RGB
	#define LED_DRIVER ws2812
#endif

#pragma message(VAR_NAME_VALUE(DATA_PIN))
#pragma message(VAR_NAME_VALUE(SPI_INTERFACE))
#pragma message(VAR_NAME_VALUE(SPI_DATA_PIN))
#pragma message(VAR_NAME_VALUE(SPI_CLOCK_PIN))
#pragma message(VAR_NAME_VALUE(SPI_CHIP_SELECT))

#if defined(SECOND_SEGMENT_START_INDEX)
	#pragma message("Using parallel mode for segments")

	#ifdef NEOPIXEL_RGBW
			#undef LED_DRIVER
			#define LED_DRIVER sk6812p
			#define LED_DRIVER2 sk6812p
	#elif NEOPIXEL_RGB
			#undef LED_DRIVER
			#define LED_DRIVER ws2812p
			#define LED_DRIVER2 ws2812p
	#else
		#error "Parallel mode is unsupportd for selected LEDs configuration"
	#endif

	#pragma message(VAR_NAME_VALUE(LED_DRIVER))
	#pragma message(VAR_NAME_VALUE(SECOND_SEGMENT_START_INDEX))
	#pragma message(VAR_NAME_VALUE(LED_DRIVER2))
	#pragma message(VAR_NAME_VALUE(SECOND_SEGMENT_REVERSED))
#else
	#pragma message(VAR_NAME_VALUE(LED_DRIVER))

	typedef LedDriver LED_DRIVER2;
#endif

/////////////////////////////////////////////////////////////////////////
#define delay(x) sleep_ms(x)
#define yield() busy_wait_us(100)
#define millis xTaskGetTickCount

#include "main.h"

static void core1()
{
	for( ;; )
	{
		if (sem_acquire_timeout_us(&base.receiverSemaphore, portMAX_DELAY))
		{
			processData();
		}
	}
}

static uint initSpi(uint baudrate, spi_inst_t* _spi, uint32_t spiMosipin, uint32_t spiClockpin, uint32_t spiSelectPin)
{
	uint selectedSpeed = spi_init(_spi, baudrate);
	printf("Using baudrate: %i\n", selectedSpeed);
	spi_set_format(_spi, 8, SPI_CPOL_1, SPI_CPHA_1, SPI_MSB_FIRST);
	hw_set_bits(&spi_get_hw(_spi)->dmacr, SPI_SSPDMACR_TXDMAE_BITS | SPI_SSPDMACR_RXDMAE_BITS);
	spi_set_slave(_spi, true);
	hw_set_bits(&spi_get_hw(_spi)->cr1, SPI_SSPCR1_SSE_BITS);
	gpio_set_function(spiClockpin, GPIO_FUNC_SPI);
	gpio_set_function(spiMosipin, GPIO_FUNC_SPI);
	gpio_set_function(spiSelectPin, GPIO_FUNC_SPI);
	gpio_set_function(3, GPIO_FUNC_SPI);
	bi_decl(bi_4pins_with_func(spiMosipin, 3, spiClockpin, spiSelectPin, GPIO_FUNC_SPI));
	
	uint dmaChannelNumber = dma_claim_unused_channel(true);
	dma_channel_config channelConfig = dma_channel_get_default_config(dmaChannelNumber);
	channel_config_set_transfer_data_size(&channelConfig, DMA_SIZE_8);
	channel_config_set_dreq(&channelConfig, spi_get_dreq(_spi, false));
	channel_config_set_read_increment(&channelConfig, false);
	channel_config_set_write_increment(&channelConfig, true);
	dma_channel_configure(dmaChannelNumber, &channelConfig,
						  spiBuffer,
						  &spi_get_hw(_spi)->dr,
						  sizeof(spiBuffer),
						  false);
	return dmaChannelNumber;
}

static void core0( void *pvParameters )
{
	uint dmaChannelNumber = initSpi(SPI_SPEED, SPI_INTERFACE, SPI_DATA_PIN, SPI_CLOCK_PIN, SPI_CHIP_SELECT);

	while(true)
	{
		dma_channel_set_write_addr(dmaChannelNumber, spiBuffer, true);
		dma_channel_wait_for_finish_blocking(dmaChannelNumber);

		int remains = SPI_FRAME_SIZE;
		int wanted, received;
		do
		{
			wanted = std::min(MAX_BUFFER - base.queueEnd, MAX_BUFFER - 1);
			received = std::min(remains, wanted);
			memcpy((void*)&(base.buffer[base.queueEnd]), &(spiBuffer[SPI_FRAME_SIZE - remains]), received);
			base.queueEnd = (base.queueEnd + received) % (MAX_BUFFER);
			remains -= received;
		}while(remains);
		
		sem_release(&base.receiverSemaphore);
	}
}

int main(void)
{
	stdio_init_all();

	sem_init(&base.receiverSemaphore, 0, 1);

	multicore_launch_core1(core1);
	
	xTaskCreate(core0,
			"HyperSPI:core0",
			configMINIMAL_STACK_SIZE * 2,
			NULL,
			(configMAX_PRIORITIES - 1),
			&base.processSerialHandle);	

	vTaskStartScheduler();
	panic_unsupported();
}
